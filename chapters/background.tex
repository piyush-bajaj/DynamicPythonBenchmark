In this chapter, we provide an overview of the topics needed to understand the work done in this thesis.

\section{Benchmarks}
% \islem{there are no citations to any existing benchmarks}
Benchmarks are tools used to measure the performance and efficiency of computer systems or components.
They evaluate the speed and quality of hardware, software, and applications to optimize performance, identify bottlenecks, and make informed decisions about system configurations.
There are many types of benchmarks that measure specific aspects of a computer system, such as processing power, memory speed, disk access time, or application performance.
Benchmarks simulate real-world workloads and produce scores that can be compared across different systems or components.
When it comes to evaluating the performance of a software system, there are two primary types of benchmarks: static benchmarks and dynamic benchmarks.
Static benchmarks involve running a predetermined set of tests on a given system or application, with fixed input parameters and test conditions.
% These benchmarks are useful for measuring the absolute performance of a system under a specific set of circumstances, and can be used to compare the performance of different systems or implementations against one another.
Dynamic benchmarks involve running a set of tests that are designed to adapt and respond to the behavior of the system being tested. 
These benchmarks are typically more complex than static benchmarks.
% However, benchmark results may not always be reliable due to factors such as hardware compatibility, software optimization, and testing conditions.
%To ensure accuracy and reliability, it is important to use multiple benchmarks, perform tests under different conditions, and interpret results carefully.
Overall, benchmarks are an essential tool for evaluating computer systems and components, enabling users to optimize performance and make informed decisions about hardware and software configurations \cite{Benchmarking_2022, Benchmarking_2023}.

% \section{Docker}
% \islem{unncessary}
% Docker is a platform that enables developers to containerize an application and its dependencies, making it easier to deploy and manage software across different environments.
% Docker containers are lightweight and portable, and Docker Hub is a cloud-based repository where developers can store and share their Docker containers.
% It provides a centralized platform for managing container images and features such as image management, automated builds, and security scanning, which help developers maintain the quality and security of their containers.
% Docker Hub also includes a registry service, which simplifies the deployment process and makes it easier to manage and scale applications in different environments.
% In summary, Docker and Docker Hub are powerful tools that enable developers to build, deploy, and manage software more efficiently and effectively through containerization and centralized repository management.

% \section{Scripting in Software Development}
% \islem{unnecessary}
% Scripting in software development refers to the use of scripting languages to automate various tasks, such as building and deploying software, managing databases, and testing software.
% Scripting is a way to execute a sequence of commands automatically, without the need for manual intervention.
% By using scripts, developers can save time and effort, and focus on other important tasks. Python and Bash are popular scripting languages used in software development.
% Python is known for its readability and ease of use across different operating systems.
% Bash is a Unix shell scripting language used primarily in Linux and Unix operating systems, and is powerful for system administration and automation.
% Scripting enables developers and administrators to automate repetitive tasks and improve efficiency.

\section{Code Analysis Frameworks}
Code analysis frameworks are tools used in software development to analyze source code and identify potential issues, vulnerabilities, and errors.
They help developers to maintain code quality, improve security, and ensure compliance with coding standards and best practices.
% These frameworks identify issues such as code smells, potential security vulnerabilities, coding errors, and violations of coding standards.
Popular code analysis frameworks include SonarQube, Checkstyle, ESLint, and Fortify, among others \cite{static_code_analysis_tools}.
These frameworks are valuable tools for software developers as they provide detailed reporting and analysis features, enforce coding standards, identify potential errors, and help to remediate security vulnerabilities.
Ultimately, code analysis frameworks help developers to write better, more secure, and higher-quality software code \cite{Code_analysis_1, Code_analysis_2, static_code_analysis}.
In our benchmark, we use two code analysis frameworks.
We use DynaPyt to perform dynamic analysis and PyCG to generate call graphs using static analysis of code.

\subsection{DynaPyt}
DynaPyt  \cite{DynaPyt2022} is a tool for dynamic analysis of Python code.
It aims to provide insights into the behavior of Python programs, such as performance and memory usage, by analyzing the runtime behavior of code.
DynaPyt provides several features, such as the ability to collect data on function calls, memory allocation, and object creation, and to visualize the results in a user-friendly interface.
The tool is designed to be easy to use and to work with existing Python code, making it accessible to a wide range of users, from researchers to developers.
The tool makes it possible to get a detailed understanding of the behavior of Python programs.
This information can be used to identify performance bottlenecks and optimize the program for better performance.
With its ease of use, flexibility, and range of features, DynaPyt is a valuable tool for anyone working with Python code.

\subsection{PyCG}
Call graphs are useful in various contexts, including profiling and vulnerability analysis.
Despite Python's popularity, there are very few tools available for generating call graphs, and these tools suffer from effectiveness issues that limit their practicality.
PyCG \cite{PyCG_2021} proposes a static approach for call graph generation in Python, which involves computing all assignment relations between program identifiers of functions, variables, classes, and modules through an inter-procedural analysis.
The resulting call graph is produced by resolving all calls to potentially invoked functions.
The proposed approach is designed to be efficient and scalable, handling several Python features such as modules, generators, function closures, and multiple inheritance.

% \section{Neural Models for Code Analysis}
% Neural models or neural networks can be used in code analysis to improve the accuracy and efficiency of code analysis tasks.
% These models can be trained to classify code, generate code, and detect code smells, potential security vulnerabilities, coding errors, and violations of coding standards.
% By analyzing patterns and relationships within code, neural models can identify potential issues that may not be easily detected through manual code analysis.
% Neural models have the potential to provide developers with new tools for maintaining code quality, improving security, and ensuring compliance with coding standards and best practices.

% \section{Call Graphs}
% Call graphs are visual representations of the relationships between functions or methods in a program used in software development.
% They help developers understand the flow of control in a program, identify potential bottlenecks, optimize performance, and debug issues more quickly.
% Call graphs can be created manually or automatically using static and dynamic analysis techniques.
% Tools such as Eclipse Call Graph, Doxygen, and Graphviz provide different levels of detail and customization options for call graphs.
% In summary, call graphs are an essential tool for understanding and analyzing complex software systems, helping developers to visualize the relationships between functions and optimize code for better performance and maintainability.
