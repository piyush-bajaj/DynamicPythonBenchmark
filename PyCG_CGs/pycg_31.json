{"test.test_point": [], "test.test_point.PointTestCase.test_point_float": ["geopy.point.Point", "unittest.TestCase.assertEqual"], "geopy.point.Point": [], "unittest.TestCase.assertEqual": [], "test.test_point.PointTestCase.test_point_str_simple": ["geopy.point.Point", "unittest.TestCase.assertEqual"], "test.test_point.PointTestCase.test_point_str_deg": ["geopy.point.Point", "unittest.TestCase.assertEqual"], "test.test_point.PointTestCase.test_point_format": ["geopy.point.Point", "unittest.TestCase.assertRaises", "unittest.TestCase.assertEqual"], "unittest.TestCase.assertRaises": [], "test.test_point.PointTestCase.test_point_from_string": ["geopy.point.Point", "unittest.TestCase.assertEqual"], "test.test_point.PointTestCase.test_point_format_altitude": ["geopy.point.Point", "unittest.TestCase.assertEqual"], "test.test_point.PointTestCase.test_point_from_iterable": ["geopy.point.Point", "unittest.TestCase.assertRaises", "unittest.TestCase.assertEqual"], "test.test_point.PointTestCase.test_point_from_single_number": ["<builtin>.tuple", "geopy.point.Point", "unittest.TestCase.assertRaises", "unittest.TestCase.assertEqual"], "<builtin>.tuple": [], "test.test_point.PointTestCase.test_point_from_point": ["unittest.TestCase.assertTrue", "<builtin>.tuple", "geopy.point.Point", "unittest.TestCase.assertEqual"], "unittest.TestCase.assertTrue": [], "test.test_point.PointTestCase.test_point_from_generator": ["<builtin>.tuple", "geopy.point.Point", "<builtin>.range", "unittest.TestCase.assertEqual"], "<builtin>.range": [], "test.test_point.PointTestCase.test_point_degrees_are_normalized": ["<builtin>.tuple", "warnings.catch_warnings", "warnings.simplefilter", "geopy.point.Point", "unittest.TestCase.assertRaises", "unittest.TestCase.assertEqual", "math.copysign", "<builtin>.len"], "warnings.catch_warnings": [], "warnings.simplefilter": [], "<builtin>.len": [], "math.copysign": [], "test.test_point.PointTestCase.test_point_degrees_normalization_does_not_lose_precision": ["<builtin>.tuple", "geopy.point.Point", "unittest.SkipTest", "unittest.TestCase.assertEqual"], "unittest.SkipTest": [], "test.test_point.PointTestCase.test_unpacking": ["geopy.point.Point", "unittest.TestCase.assertEqual"], "test.test_point.PointTestCase.test_point_no_len": ["geopy.point.Point", "unittest.TestCase.assertRaises", "<builtin>.len"], "test.test_point.PointTestCase.test_point_getitem": ["geopy.point.Point", "unittest.TestCase.assertEqual"], "test.test_point.PointTestCase.test_point_slices": ["<builtin>.tuple", "geopy.point.Point", "unittest.TestCase.assertRaises", "unittest.TestCase.assertEqual"], "test.test_point.PointTestCase.test_point_setitem": ["<builtin>.tuple", "geopy.point.Point", "unittest.TestCase.assertEqual"], "test.test_point.PointTestCase.test_point_setitem_normalization": ["<builtin>.tuple", "warnings.catch_warnings", "warnings.simplefilter", "geopy.point.Point", "unittest.TestCase.assertRaises", "unittest.TestCase.assertEqual", "<builtin>.float", "<builtin>.len"], "<builtin>.float": [], "test.test_point.PointTestCase.test_point_assign_coordinates": ["<builtin>.tuple", "geopy.point.Point", "unittest.TestCase.assertEqual"], "test.test_point.PointTestCase.test_point_eq": ["geopy.point.Point", "unittest.TestCase.assertEqual"], "test.test_point.PointTestCase.test_point_ne": ["unittest.TestCase.assertTrue", "geopy.point.Point"], "test.test_point.PointTestCase.test_point_comparison_does_not_raise_exceptions": ["unittest.TestCase.assertTrue", "geopy.point.Point", "<builtin>.object", "unittest.TestCase.assertFalse"], "<builtin>.object": [], "unittest.TestCase.assertFalse": [], "test.test_point.PointTestCase.test_point_comparison_with_empty_values": ["unittest.TestCase.assertTrue", "geopy.point.Point", "unittest.TestCase.assertFalse", "unittest.TestCase.assertEqual"], "test.test_point.PointTestCase.test_point_comparison_respects_lists": ["unittest.TestCase.assertTrue", "geopy.point.Point", "unittest.TestCase.assertFalse"], "test.test_point.PointTestCase.test_point_comparison_ignores_strings": ["unittest.TestCase.assertTrue", "geopy.point.Point", "unittest.TestCase.assertFalse"], "test.test_point.PointTestCase.test_point_is_picklable": ["pickle.dumps", "geopy.point.Point", "pickle.loads", "unittest.TestCase.assertEqual"], "pickle.dumps": [], "pickle.loads": [], "test.geocoders.maptiler": [], "test.geocoders.maptiler.TestMapTiler.make_geocoder": ["geopy.geocoders.MapTiler"], "geopy.geocoders.MapTiler": [], "test.geocoders.maptiler.TestMapTiler.test_geocode": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.util.BaseTestGeocoder.geocode_run": ["<builtin>.type", "pytest.fail"], "test.geocoders.maptiler.TestMapTiler.test_reverse": ["geopy.point.Point", "test.geocoders.util.BaseTestGeocoder.reverse_run"], "test.geocoders.util.BaseTestGeocoder.reverse_run": ["<builtin>.type", "pytest.fail"], "test.geocoders.maptiler.TestMapTiler.test_zero_results": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.maptiler.TestMapTiler.test_geocode_outside_bbox": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.maptiler.TestMapTiler.test_geocode_bbox": ["geopy.point.Point", "test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.maptiler.TestMapTiler.test_geocode_proximity": ["geopy.point.Point", "test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.maptiler.TestMapTiler.test_reverse_language": ["geopy.point.Point", "test.geocoders.util.BaseTestGeocoder.reverse_run"], "test.geocoders.maptiler.TestMapTiler.test_geocode_language": ["geopy.point.Point", "test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.maptiler.TestMapTiler.test_geocode_raw": ["pytest.approx", "test.geocoders.util.BaseTestGeocoder.geocode_run"], "pytest.approx": [], "test.geocoders.maptiler.TestMapTiler.test_geocode_exactly_one_false": ["<builtin>.len", "test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.openmapquest": [], "test.geocoders.openmapquest.TestUnitOpenMapQuest.test_user_agent_custom": ["geopy.geocoders.OpenMapQuest"], "geopy.geocoders.OpenMapQuest": [], "test.geocoders.openmapquest.TestOpenMapQuest.make_geocoder": ["geopy.geocoders.OpenMapQuest"], "test.geocoders.base": ["pytest.mark.parametrize"], "test.geocoders.base.DummySyncAdapter.get_json": [], "test.geocoders.base.DummySyncAdapter.get_text": [], "test.geocoders.base.DummyAsyncAdapter.get_json": [], "test.geocoders.base.DummyAsyncAdapter.get_text": [], "test.geocoders.base.GetGeocoderTestCase.test_get_geocoder_for_service": ["geopy.geocoders.get_geocoder_for_service"], "geopy.geocoders.get_geocoder_for_service": [], "test.geocoders.base.GetGeocoderTestCase.test_get_geocoder_for_service_raises_for_unknown": ["pytest.raises", "geopy.geocoders.get_geocoder_for_service"], "pytest.raises": [], "test.geocoders.base.GeocoderTestCase.setUpClass": ["geopy.geocoders.base.Geocoder"], "geopy.geocoders.base.Geocoder": [], "test.geocoders.base.GeocoderTestCase.test_init_with_args": ["geopy.adapters.BaseSyncAdapter.__init__", "<builtin>.locals", "geopy.geocoders.base.Geocoder", "<builtin>.getattr"], "geopy.adapters.BaseSyncAdapter.__init__": [], "test.geocoders.base.GeocoderTestCase.test_init_with_args.<lambda1>": [], "<builtin>.locals": [], "<builtin>.getattr": [], "unittest.mock.patch.object": [], "test.geocoders.base.GeocoderTestCase": ["unittest.mock.patch.object"], "test.geocoders.base.GeocoderTestCase.test_init_with_defaults": ["<builtin>.type", "geopy.geocoders.base.Geocoder", "<builtin>.getattr"], "<builtin>.type": [], "test.geocoders.base.GeocoderTestCase.test_init_with_none_overrides_default": ["geopy.geocoders.base.Geocoder"], "test.geocoders.base.GeocoderTestCase.test_user_agent_default": ["geopy.geocoders.base.Geocoder"], "test.geocoders.base.GeocoderTestCase.test_user_agent_custom": ["geopy.geocoders.base.Geocoder"], "test.geocoders.base.GeocoderTestCase.test_call_geocoder_timeout": ["unittest.mock.patch.object", "geopy.geocoders.base.Geocoder", "contextlib.ExitStack"], "contextlib.ExitStack": [], "test.geocoders.base.GeocoderTestCase.test_call_geocoder_timeout.<lambda1>": [], "test.geocoders.base.GeocoderTestCase.test_call_geocoder_timeout.<lambda2>": [], "test.geocoders.base.GeocoderTestCase.test_call_geocoder_timeout.<lambda3>": [], "test.geocoders.base.GeocoderTestCase.test_ssl_context": ["unittest.mock.patch.object", "geopy.adapters.BaseSyncAdapter.__init__", "geopy.geocoders.base.Geocoder", "contextlib.ExitStack"], "test.geocoders.base.GeocoderPointCoercionTestCase.setUp": ["geopy.geocoders.base.Geocoder"], "test.geocoders.base.GeocoderPointCoercionTestCase.test_point": ["geopy.point.Point"], "test.geocoders.base.GeocoderPointCoercionTestCase.test_tuple_of_floats": [], "test.geocoders.base.GeocoderPointCoercionTestCase.test_string": [], "test.geocoders.base.GeocoderPointCoercionTestCase.test_string_is_trimmed": [], "test.geocoders.base.GeocoderPointCoercionTestCase.test_output_format_is_respected": [], "test.geocoders.base.GeocoderPointCoercionTestCase.test_address": ["pytest.raises"], "test.geocoders.base.GeocoderPointCoercionTestCase.test_near_zero": ["geopy.point.Point"], "test.geocoders.base.GeocoderFormatBoundingBoxTestCase.setUp": ["geopy.geocoders.base.Geocoder"], "test.geocoders.base.GeocoderFormatBoundingBoxTestCase.test_string_raises": ["pytest.raises"], "test.geocoders.base.GeocoderFormatBoundingBoxTestCase.test_list_of_1_raises": ["pytest.raises"], "test.geocoders.base.GeocoderFormatBoundingBoxTestCase.test_list_of_3_raises": ["pytest.raises"], "test.geocoders.base.GeocoderFormatBoundingBoxTestCase.test_list_of_4_raises": ["pytest.raises"], "test.geocoders.base.GeocoderFormatBoundingBoxTestCase.test_list_of_5_raises": ["pytest.raises"], "test.geocoders.base.GeocoderFormatBoundingBoxTestCase.test_points": ["geopy.point.Point"], "test.geocoders.base.GeocoderFormatBoundingBoxTestCase.test_lists": [], "test.geocoders.base.GeocoderFormatBoundingBoxTestCase.test_strings": [], "test.geocoders.base.GeocoderFormatBoundingBoxTestCase.test_output_format": ["geopy.point.Point"], "pytest.mark.parametrize": [], "test.geocoders.base.test_synchronize_decorator_sync_simple": ["geopy.geocoders.base._synchronized", "test.geocoders.base.test_synchronize_decorator_sync_simple.f", "geopy.geocoders.base.Geocoder"], "geopy.geocoders.base._synchronized": [], "test.geocoders.base.test_synchronize_decorator_sync_simple.f": [], "test.geocoders.base.test_synchronize_decorator_async_simple": ["geopy.geocoders.base._synchronized", "geopy.geocoders.base.Geocoder", "test.geocoders.base.test_synchronize_decorator_async_simple.f"], "test.geocoders.base.test_synchronize_decorator_async_simple.f": ["test.geocoders.base.test_synchronize_decorator_async_simple.f.coro"], "test.geocoders.base.test_synchronize_decorator_async_simple.f.coro": [], "test.geocoders.base.test_synchronize_decorator_sync_exception": ["geopy.geocoders.base._synchronized", "pytest.raises", "geopy.geocoders.base.Geocoder", "test.geocoders.base.test_synchronize_decorator_sync_exception.f"], "test.geocoders.base.test_synchronize_decorator_sync_exception.f": ["<builtin>.RuntimeError"], "<builtin>.RuntimeError": [], "test.geocoders.base.test_synchronize_decorator_async_exception": ["geopy.geocoders.base._synchronized", "pytest.raises", "geopy.geocoders.base.Geocoder", "test.geocoders.base.test_synchronize_decorator_async_exception.f"], "test.geocoders.base.test_synchronize_decorator_async_exception.f": ["test.geocoders.base.test_synchronize_decorator_async_exception.f.coro"], "test.geocoders.base.test_synchronize_decorator_async_exception.f.coro": ["<builtin>.RuntimeError"], "test.geocoders.base.test_synchronize_decorator_sync_reentrance": ["geopy.geocoders.base.Geocoder.__init__", "test.geocoders.base.test_synchronize_decorator_sync_reentrance.DummyGeocoder.f", "<builtin>.range", "<builtin>.list"], "test.geocoders.base.test_synchronize_decorator_sync_reentrance.DummyGeocoder": ["geopy.geocoders.base._synchronized"], "test.geocoders.base.test_synchronize_decorator_sync_reentrance.DummyGeocoder.f": ["<builtin>.len", "test.geocoders.base.test_synchronize_decorator_sync_reentrance.DummyGeocoder.f"], "geopy.geocoders.base.Geocoder.__init__": [], "<builtin>.list": [], "test.geocoders.base.test_synchronize_decorator_async_reentrance": ["geopy.geocoders.base.Geocoder.__init__", "test.geocoders.base.test_synchronize_decorator_async_reentrance.DummyGeocoder.f", "<builtin>.range", "<builtin>.list"], "test.geocoders.base.test_synchronize_decorator_async_reentrance.DummyGeocoder": ["geopy.geocoders.base._synchronized"], "test.geocoders.base.test_synchronize_decorator_async_reentrance.DummyGeocoder.f": ["test.geocoders.base.test_synchronize_decorator_async_reentrance.DummyGeocoder.f.coro"], "test.geocoders.base.test_synchronize_decorator_async_reentrance.DummyGeocoder.f.coro": ["test.geocoders.base.test_synchronize_decorator_async_reentrance.DummyGeocoder.f", "<builtin>.len"], "test.geocoders.algolia": [], "test.geocoders.algolia.TestAlgoliaPlaces.make_geocoder": ["geopy.geocoders.AlgoliaPlaces"], "geopy.geocoders.AlgoliaPlaces": [], "test.geocoders.algolia.TestAlgoliaPlaces.test_user_agent_custom": ["test.geocoders.algolia.TestAlgoliaPlaces.make_geocoder"], "test.geocoders.algolia.TestAlgoliaPlaces.test_geocode": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.algolia.TestAlgoliaPlaces.test_reverse": ["test.geocoders.util.BaseTestGeocoder.reverse_run"], "test.geocoders.algolia.TestAlgoliaPlaces.test_explicit_type": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.algolia.TestAlgoliaPlaces.test_limit": ["<builtin>.len", "test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.algolia.TestAlgoliaPlaces.test_countries": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.algolia.TestAlgoliaPlaces.test_countries_no_result": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.algolia.TestAlgoliaPlaces.test_geocode_no_result": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.algolia.TestAlgoliaPlaces.test_around": ["geopy.point.Point", "test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.bing": [], "test.geocoders.bing.TestUnitBing.test_user_agent_custom": ["geopy.geocoders.Bing"], "geopy.geocoders.Bing": [], "test.geocoders.bing.TestBing.make_geocoder": ["geopy.geocoders.Bing"], "test.geocoders.bing.TestBing.test_geocode": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.bing.TestBing.test_reverse_point": ["geopy.point.Point", "test.geocoders.util.BaseTestGeocoder.reverse_run"], "test.geocoders.bing.TestBing.test_reverse_with_culture_de": ["geopy.point.Point", "test.geocoders.util.BaseTestGeocoder.reverse_run"], "test.geocoders.bing.TestBing.test_reverse_with_culture_en": ["geopy.point.Point", "test.geocoders.util.BaseTestGeocoder.reverse_run"], "test.geocoders.bing.TestBing.test_reverse_with_include_country_code": ["geopy.point.Point", "test.geocoders.util.BaseTestGeocoder.reverse_run"], "test.geocoders.bing.TestBing.test_user_location": ["geopy.point.Point", "test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.bing.TestBing.test_optional_params": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.bing.TestBing.test_structured_query": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.azure": [], "test.geocoders.azure.TestAzureMaps.make_geocoder": ["geopy.geocoders.AzureMaps"], "geopy.geocoders.AzureMaps": [], "test.geocoders.geocodio": [], "test.geocoders.geocodio.TestGeocodio.make_geocoder": ["geopy.geocoders.Geocodio"], "geopy.geocoders.Geocodio": [], "test.geocoders.geocodio.TestGeocodio.test_user_agent_custom": ["test.geocoders.geocodio.TestGeocodio.make_geocoder"], "test.geocoders.geocodio.TestGeocodio.test_error_with_only_street": ["pytest.raises", "test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.geocodio.TestGeocodio.test_geocode": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.geocodio.TestGeocodio.test_geocode_from_components": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.geocodio.TestGeocodio.test_geocode_many_results": ["<builtin>.len", "test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.geocodio.TestGeocodio.test_reverse": ["geopy.point.Point", "test.geocoders.util.BaseTestGeocoder.reverse_run"], "test.geocoders.geocodio.TestGeocodio.test_geocode_no_result": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.geocodio.TestGeocodio.test_geocode_structured_no_result": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.geocodio.TestGeocodio.test_reverse_no_result": ["test.geocoders.util.BaseTestGeocoder.reverse_run"], "test.geocoders.googlev3": [], "test.geocoders.googlev3.TestGoogleV3": ["geopy.point.Point", "pytest.mark.skipif"], "test.geocoders.googlev3.TestGoogleV3.make_geocoder": ["geopy.geocoders.GoogleV3"], "geopy.geocoders.GoogleV3": [], "test.geocoders.googlev3.TestGoogleV3.test_user_agent_custom": ["geopy.geocoders.GoogleV3"], "test.geocoders.googlev3.TestGoogleV3.test_configuration_error": ["pytest.raises", "geopy.geocoders.GoogleV3"], "test.geocoders.googlev3.TestGoogleV3.test_error_with_no_api_key": ["pytest.raises", "geopy.geocoders.GoogleV3"], "test.geocoders.googlev3.TestGoogleV3.test_no_error_with_no_api_key_but_using_premier": ["geopy.geocoders.GoogleV3"], "test.geocoders.googlev3.TestGoogleV3.test_check_status": ["test.geocoders.googlev3.TestGoogleV3.test_check_status.make_error", "pytest.raises"], "test.geocoders.googlev3.TestGoogleV3.test_check_status.make_error": [], "test.geocoders.googlev3.TestGoogleV3.test_get_signed_url": ["base64.urlsafe_b64encode", "geopy.geocoders.GoogleV3"], "base64.urlsafe_b64encode": [], "test.geocoders.googlev3.TestGoogleV3.test_get_signed_url_with_channel": ["urllib.parse.urlparse", "base64.urlsafe_b64encode", "urllib.parse.parse_qs", "geopy.geocoders.GoogleV3"], "urllib.parse.urlparse": [], "urllib.parse.parse_qs": [], "test.geocoders.googlev3.TestGoogleV3.test_format_components_param": ["pytest.raises"], "test.geocoders.googlev3.TestGoogleV3.test_geocode": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.googlev3.TestGoogleV3.test_geocode_with_conflicting_components": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.googlev3.TestGoogleV3.test_components": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.googlev3.TestGoogleV3.test_components_without_query": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.googlev3.TestGoogleV3.test_reverse": ["test.geocoders.util.BaseTestGeocoder.reverse_run"], "test.geocoders.googlev3.TestGoogleV3.test_zero_results": ["pytest.raises", "test.geocoders.util.BaseTestGeocoder.geocode_run"], "pytest.mark.skipif": [], "test.geocoders.googlev3.TestGoogleV3.test_timezone_datetime": ["test.geocoders.util.BaseTestGeocoder.reverse_timezone_run", "datetime.datetime.utcfromtimestamp", "pytz.timezone"], "datetime.datetime.utcfromtimestamp": [], "pytz.timezone": [], "test.geocoders.util.BaseTestGeocoder.reverse_timezone_run": [], "test.geocoders.googlev3.TestGoogleV3.test_timezone_at_time_normalization": ["datetime.datetime", "pytz.timezone"], "datetime.datetime": [], "test.geocoders.googlev3.TestGoogleV3.test_timezone_integer_raises": ["pytest.raises", "test.geocoders.util.BaseTestGeocoder.reverse_timezone_run", "pytz.timezone"], "test.geocoders.googlev3.TestGoogleV3.test_timezone_no_date": ["test.geocoders.util.BaseTestGeocoder.reverse_timezone_run", "pytz.timezone"], "test.geocoders.googlev3.TestGoogleV3.test_timezone_invalid_at_time": ["pytest.raises"], "test.geocoders.googlev3.TestGoogleV3.test_reverse_timezone_unknown": ["test.geocoders.util.BaseTestGeocoder.reverse_timezone_run"], "test.geocoders.googlev3.TestGoogleV3.test_geocode_bounds": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.googlev3.TestGoogleV3.test_geocode_bounds_invalid": ["pytest.raises", "test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.googlev3.TestGoogleV3.test_geocode_place_id_invalid": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.googlev3.TestGoogleV3.test_geocode_place_id_not_invalid": ["pytest.raises", "test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.googlev3.TestGoogleV3.test_place_id_zero_result": ["pytest.raises", "test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.googlev3.TestGoogleV3.test_geocode_place_id_with_query": ["pytest.raises", "test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.googlev3.TestGoogleV3.test_geocode_place_id_with_bounds": ["pytest.raises", "test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.googlev3.TestGoogleV3.test_geocode_place_id_with_query_and_bounds": ["pytest.raises", "test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.opencage": [], "test.geocoders.opencage.TestUnitOpenCage.test_user_agent_custom": ["geopy.geocoders.OpenCage"], "geopy.geocoders.OpenCage": [], "test.geocoders.opencage.TestOpenCage.make_geocoder": ["geopy.geocoders.OpenCage"], "test.geocoders.opencage.TestOpenCage.test_geocode": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.opencage.TestOpenCage.test_geocode_empty_result": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.opencage.TestOpenCage.test_bounds": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.opencage.TestOpenCage.test_country_str": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.opencage.TestOpenCage.test_country_list": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.opencage.TestOpenCage.test_geocode_annotations": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.opencage.TestOpenCage.test_payment_required_error": ["geopy.geocoders.OpenCage", "test.geocoders.util.BaseTestGeocoder.inject_geocoder", "pytest.raises", "test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.util.BaseTestGeocoder.inject_geocoder": ["<builtin>.isinstance", "unittest.mock.patch.object"], "test.geocoders.opencage.TestOpenCage.test_api_key_disabled_error": ["geopy.geocoders.OpenCage", "test.geocoders.util.BaseTestGeocoder.inject_geocoder", "pytest.raises", "test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.opencage.TestOpenCage.test_rate_limited_error": ["geopy.geocoders.OpenCage", "test.geocoders.util.BaseTestGeocoder.inject_geocoder", "pytest.raises", "test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.arcgis": [], "test.geocoders.arcgis.TestUnitArcGIS.test_user_agent_custom": ["geopy.geocoders.ArcGIS"], "geopy.geocoders.ArcGIS": [], "test.geocoders.arcgis.TestArcGIS.make_geocoder": ["geopy.geocoders.ArcGIS"], "test.geocoders.arcgis.TestArcGIS.test_missing_password_error": ["pytest.raises", "geopy.geocoders.ArcGIS"], "test.geocoders.arcgis.TestArcGIS.test_scheme_config_error": ["pytest.raises", "geopy.geocoders.ArcGIS"], "test.geocoders.arcgis.TestArcGIS.test_geocode": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.arcgis.TestArcGIS.test_empty_response": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.arcgis.TestArcGIS.test_geocode_with_out_fields_string": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.arcgis.TestArcGIS.test_geocode_with_out_fields_list": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.arcgis.TestArcGIS.test_reverse_point": ["geopy.point.Point", "test.geocoders.util.BaseTestGeocoder.reverse_run"], "test.geocoders.arcgis.TestArcGIS.test_reverse_not_exactly_one": ["geopy.point.Point", "test.geocoders.util.BaseTestGeocoder.reverse_run"], "test.geocoders.arcgis.TestArcGIS.test_reverse_long_label_address": ["test.geocoders.util.BaseTestGeocoder.reverse_run"], "test.geocoders.arcgis.TestArcGISAuthenticated.make_geocoder": ["geopy.geocoders.ArcGIS"], "test.geocoders.arcgis.TestArcGISAuthenticated.test_basic_address": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.baidu": [], "test.geocoders.baidu.TestUnitBaidu.make_geocoder": ["geopy.geocoders.Baidu"], "geopy.geocoders.Baidu": [], "test.geocoders.baidu.TestUnitBaidu.test_user_agent_custom": [], "test.geocoders.baidu.BaseTestBaidu.test_basic_address": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.baidu.BaseTestBaidu.test_reverse_point": ["geopy.point.Point", "test.geocoders.util.BaseTestGeocoder.reverse_run"], "test.geocoders.baidu.TestBaidu.make_geocoder": ["geopy.geocoders.Baidu"], "test.geocoders.baidu.TestBaidu.test_invalid_ak": ["test.geocoders.util.BaseTestGeocoder.geocode_run", "geopy.geocoders.Baidu", "<builtin>.str", "pytest.raises", "test.geocoders.util.BaseTestGeocoder.inject_geocoder"], "<builtin>.str": [], "test.geocoders.baidu.TestBaiduSK.make_geocoder": ["geopy.geocoders.Baidu"], "test.geocoders.baidu.TestBaiduSK.test_sn_with_peculiar_chars": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.baidu.TestBaiduV3.make_geocoder": ["geopy.geocoders.BaiduV3"], "geopy.geocoders.BaiduV3": [], "test.geocoders.baidu.TestBaiduV3SK.make_geocoder": ["geopy.geocoders.BaiduV3"], "test.geocoders.smartystreets": [], "test.geocoders.smartystreets.TestUnitLiveAddress.test_user_agent_custom": ["geopy.geocoders.LiveAddress"], "geopy.geocoders.LiveAddress": [], "test.geocoders.smartystreets.TestUnitLiveAddress": ["unittest.mock.patch.object"], "test.geocoders.smartystreets.TestUnitLiveAddress.test_default_scheme_is_ignored": ["geopy.geocoders.LiveAddress"], "test.geocoders.smartystreets.TestLiveAddress.make_geocoder": ["geopy.geocoders.LiveAddress"], "test.geocoders.smartystreets.TestLiveAddress.test_geocode": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.util": ["json.loads", "test.geocoders.util.SkipIfMissingEnv.__init__", "<builtin>.open"], "<builtin>.open": [], "json.loads": [], "test.geocoders.util.SkipIfMissingEnv.__init__": ["<builtin>.super"], "<builtin>.super": [], "test.geocoders.util.SkipIfMissingEnv.__getitem__": ["<builtin>.super", "pytest.skip"], "pytest.skip": [], "pytest.fixture": [], "test.geocoders.util.BaseTestGeocoder": ["contextlib.asynccontextmanager", "pytest.fixture", "abc.abstractmethod"], "test.geocoders.util.BaseTestGeocoder.class_geocoder": ["<builtin>.isinstance"], "<builtin>.isinstance": [], "contextlib.asynccontextmanager": [], "test.geocoders.util.BaseTestGeocoder.ensure_no_geocoder_assignment": ["<builtin>.type"], "abc.abstractmethod": [], "test.geocoders.util.BaseTestGeocoder.make_geocoder": [], "pytest.fail": [], "test.geocoders.util.BaseTestGeocoder._make_request": ["pytest.skip", "<builtin>.isinstance", "<builtin>.type", "<builtin>.getattr"], "test.geocoders.util.BaseTestGeocoder._verify_request": ["<builtin>.isinstance", "pytest.approx"], "test.geocoders.geonames": [], "test.geocoders.geonames.TestUnitGeoNames.test_user_agent_custom": ["geopy.geocoders.GeoNames"], "geopy.geocoders.GeoNames": [], "test.geocoders.geonames.TestGeoNames.make_geocoder": ["geopy.geocoders.GeoNames"], "test.geocoders.geonames.TestGeoNames.test_geocode": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.geonames.TestGeoNames.test_query_urlencoding": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.geonames.TestGeoNames.test_reverse": ["test.geocoders.util.BaseTestGeocoder.reverse_run"], "test.geocoders.geonames.TestGeoNames.test_geocode_empty_response": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.geonames.TestGeoNames.test_reverse_nearby_place_name_raises_for_feature_code": ["pytest.raises", "test.geocoders.util.BaseTestGeocoder.reverse_run"], "test.geocoders.geonames.TestGeoNames.test_reverse_nearby_place_name_lang": ["test.geocoders.util.BaseTestGeocoder.reverse_run"], "test.geocoders.geonames.TestGeoNames.test_reverse_find_nearby_raises_for_lang": ["pytest.raises", "test.geocoders.util.BaseTestGeocoder.reverse_run"], "test.geocoders.geonames.TestGeoNames.test_reverse_find_nearby": ["test.geocoders.util.BaseTestGeocoder.reverse_run"], "test.geocoders.geonames.TestGeoNames.test_reverse_find_nearby_feature_code": ["test.geocoders.util.BaseTestGeocoder.reverse_run"], "test.geocoders.geonames.TestGeoNames.test_reverse_raises_for_unknown_find_nearby_type": ["pytest.raises", "test.geocoders.util.BaseTestGeocoder.reverse_run"], "test.geocoders.geonames.TestGeoNames": ["pytest.mark.skipif"], "test.geocoders.geonames.TestGeoNames.test_reverse_timezone": ["test.geocoders.util.BaseTestGeocoder.reverse_timezone_run", "geopy.Point", "pytz.timezone"], "geopy.Point": [], "test.geocoders.geonames.TestGeoNames.test_reverse_timezone_unknown": ["test.geocoders.util.BaseTestGeocoder.reverse_timezone_run", "pytz.FixedOffset"], "pytz.FixedOffset": [], "test.geocoders.geonames.TestGeoNames.test_country_str": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.geonames.TestGeoNames.test_country_list": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.geonames.TestGeoNames.test_country_bias": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.geonames.TestGeoNamesInvalidAccount.make_geocoder": ["uuid.uuid4", "geopy.geocoders.GeoNames"], "uuid.uuid4": [], "test.geocoders.geonames.TestGeoNamesInvalidAccount.test_geocode": ["pytest.raises", "test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.geonames.TestGeoNamesInvalidAccount": ["pytest.mark.skipif"], "test.geocoders.geonames.TestGeoNamesInvalidAccount.test_reverse_timezone": ["pytest.raises", "test.geocoders.util.BaseTestGeocoder.reverse_timezone_run"], "test.geocoders.here": [], "test.geocoders.here.TestUnitHere.test_user_agent_custom": ["geopy.geocoders.Here"], "geopy.geocoders.Here": [], "test.geocoders.here.TestUnitHere.test_error_with_no_keys": ["geopy.geocoders.Here", "pytest.raises"], "test.geocoders.here.TestUnitHere.test_warning_with_legacy_auth": ["geopy.geocoders.Here", "<builtin>.len", "warnings.catch_warnings"], "test.geocoders.here.TestUnitHere.test_no_warning_with_apikey": ["geopy.geocoders.Here", "<builtin>.len", "warnings.catch_warnings"], "test.geocoders.here.BaseTestHere.test_geocode_empty_result": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.here.BaseTestHere.test_geocode": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.here.BaseTestHere.test_geocode_structured": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.here.BaseTestHere.test_geocode_unicode_name": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.here.BaseTestHere.test_bbox": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.here.BaseTestHere.test_mapview": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.here.BaseTestHere.test_geocode_shapes": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.here.BaseTestHere.test_geocode_with_language_de": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.here.BaseTestHere.test_geocode_with_language_en": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.here.BaseTestHere.test_geocode_with_paging": ["<builtin>.len", "test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.here.BaseTestHere.test_reverse": ["geopy.point.Point", "test.geocoders.util.BaseTestGeocoder.reverse_run"], "test.geocoders.here.BaseTestHere.test_reverse_point_radius_1000_float": ["geopy.point.Point", "test.geocoders.util.BaseTestGeocoder.reverse_run", "<builtin>.len"], "test.geocoders.here.BaseTestHere.test_reverse_point_radius_10": ["geopy.point.Point", "test.geocoders.util.BaseTestGeocoder.reverse_run", "<builtin>.len"], "test.geocoders.here.BaseTestHere.test_reverse_with_language_de": ["geopy.point.Point", "test.geocoders.util.BaseTestGeocoder.reverse_run"], "test.geocoders.here.BaseTestHere.test_reverse_with_language_en": ["geopy.point.Point", "test.geocoders.util.BaseTestGeocoder.reverse_run"], "test.geocoders.here.BaseTestHere.test_reverse_with_mode_areas": ["geopy.point.Point", "test.geocoders.util.BaseTestGeocoder.reverse_run"], "test.geocoders.here.BaseTestHere.test_reverse_with_maxresults_5": ["geopy.point.Point", "test.geocoders.util.BaseTestGeocoder.reverse_run", "<builtin>.len"], "test.geocoders.here.TestHereApiKey.make_geocoder": ["geopy.geocoders.Here"], "test.geocoders.here.TestHereLegacyAuth.make_geocoder": ["geopy.geocoders.Here", "<builtin>.len", "warnings.catch_warnings"], "test.geocoders.here.TestHereV7.make_geocoder": ["geopy.geocoders.HereV7"], "geopy.geocoders.HereV7": [], "test.geocoders.here.TestHereV7.test_geocode_empty_result": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.here.TestHereV7.test_geocode": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.here.TestHereV7.test_geocode_query_and_components": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.here.TestHereV7.test_geocode_structured": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.here.TestHereV7.test_geocode_unicode_name": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.here.TestHereV7.test_geocode_at": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.here.TestHereV7.test_geocode_countries": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.here.TestHereV7.test_geocode_language": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.here.TestHereV7.test_geocode_limit": ["<builtin>.len", "test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.here.TestHereV7.test_reverse": ["geopy.point.Point", "test.geocoders.util.BaseTestGeocoder.reverse_run"], "test.geocoders.here.TestHereV7.test_reverse_language": ["geopy.point.Point", "test.geocoders.util.BaseTestGeocoder.reverse_run"], "test.geocoders.here.TestHereV7.test_reverse_limit": ["geopy.point.Point", "test.geocoders.util.BaseTestGeocoder.reverse_run", "<builtin>.len"], "test.geocoders": ["pkgutil.iter_modules", "inspect.isclass", "<builtin>.dir", "<builtin>.sorted", "pytest.mark.parametrize", "<builtin>.issubclass", "<builtin>.getattr", "importlib.import_module"], "importlib.import_module": [], "pkgutil.iter_modules": [], "test.geocoders.<lambda1>": [], "<builtin>.sorted": [], "<builtin>.dir": [], "inspect.isclass": [], "<builtin>.issubclass": [], "test.geocoders.<lambda2>": [], "test.geocoders.assert_no_varargs": ["<builtin>.str"], "test.geocoders.assert_rst": ["<builtin>.set", "<builtin>.len", "test.geocoders.assert_rst.get_all_text", "<builtin>.list"], "test.geocoders.assert_rst.get_all_text": ["test.geocoders.assert_rst.get_all_text"], "<builtin>.set": [], "test.geocoders.test_all_geocoders_are_exported_from_package": ["<builtin>.set", "<builtin>.dir"], "test.geocoders.test_all_geocoders_are_listed_in_all": ["<builtin>.set"], "test.geocoders.test_all_geocoders_are_listed_in_service_to_geocoder": ["<builtin>.set"], "test.geocoders.<lambda3>": [], "test.geocoders.test_geocoder_module_all": ["<builtin>.tuple"], "test.geocoders.test_init_method_signature": ["inspect.signature", "test.geocoders.assert_rst", "test.geocoders.assert_no_varargs"], "inspect.signature": [], "test.geocoders.test_geocode_method_signature": ["test.geocoders.assert_rst", "test.geocoders.assert_no_varargs", "<builtin>.all", "<builtin>.list", "inspect.signature"], "<builtin>.all": [], "test.geocoders.test_reverse_method_signature": ["test.geocoders.assert_rst", "test.geocoders.assert_no_varargs", "<builtin>.all", "<builtin>.list", "inspect.signature"], "test.geocoders.test_reverse_timezone_method_signature": ["test.geocoders.assert_rst", "test.geocoders.assert_no_varargs", "<builtin>.all", "<builtin>.list", "inspect.signature"], "test.geocoders.test_no_extra_public_methods": ["inspect.isfunction", "<builtin>.getattr", "<builtin>.dir"], "inspect.isfunction": [], "test.geocoders.mapbox": [], "test.geocoders.mapbox.TestMapBox.make_geocoder": ["geopy.geocoders.MapBox"], "geopy.geocoders.MapBox": [], "test.geocoders.mapbox.TestMapBox.test_geocode": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.mapbox.TestMapBox.test_reverse": ["geopy.point.Point", "test.geocoders.util.BaseTestGeocoder.reverse_run"], "test.geocoders.mapbox.TestMapBox.test_zero_results": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.mapbox.TestMapBox.test_geocode_outside_bbox": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.mapbox.TestMapBox.test_geocode_bbox": ["geopy.point.Point", "test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.mapbox.TestMapBox.test_geocode_proximity": ["geopy.point.Point", "test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.mapbox.TestMapBox.test_geocode_country_str": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.mapbox.TestMapBox.test_geocode_country_list": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.mapbox.TestMapBox.test_geocode_raw": ["pytest.approx", "test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.mapbox.TestMapBox.test_geocode_exactly_one_false": ["<builtin>.len", "test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.mapbox.TestMapBox.test_geocode_language": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.banfrance": [], "test.geocoders.banfrance.TestBANFrance.make_geocoder": ["geopy.geocoders.BANFrance"], "geopy.geocoders.BANFrance": [], "test.geocoders.banfrance.TestBANFrance.test_user_agent_custom": ["geopy.geocoders.BANFrance"], "test.geocoders.banfrance.TestBANFrance.test_geocode_with_address": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.banfrance.TestBANFrance.test_reverse": ["test.geocoders.util.BaseTestGeocoder.reverse_run"], "test.geocoders.banfrance.TestBANFrance.test_geocode_limit": ["<builtin>.len", "test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.photon": [], "test.geocoders.photon.TestPhoton.make_geocoder": ["geopy.geocoders.Photon"], "geopy.geocoders.Photon": [], "test.geocoders.photon.TestPhoton.test_user_agent_custom": ["geopy.geocoders.Photon"], "test.geocoders.photon.TestPhoton.test_geocode": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.photon.TestPhoton.test_osm_tag": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.photon.TestPhoton.test_bbox": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.photon.TestPhoton.test_reverse": ["geopy.point.Point", "test.geocoders.util.BaseTestGeocoder.reverse_run"], "test.geocoders.photon.TestPhoton.test_geocode_language_parameter": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.photon.TestPhoton.test_reverse_language_parameter": ["test.geocoders.util.BaseTestGeocoder.reverse_run"], "test.geocoders.nominatim": [], "test.geocoders.nominatim.BaseTestNominatim.test_geocode": [], "test.geocoders.nominatim.BaseTestNominatim.test_geocode_empty_result": [], "test.geocoders.nominatim.BaseTestNominatim.test_reverse_empty_result": [], "test.geocoders.nominatim.BaseTestNominatim.test_limit": ["pytest.raises", "<builtin>.len"], "pytest.mark.skip": [], "test.geocoders.nominatim.BaseTestNominatim": ["unittest.mock.patch.object", "pytest.mark.parametrize", "pytest.mark.skip"], "test.geocoders.nominatim.BaseTestNominatim.test_user_agent_default": [], "test.geocoders.nominatim.BaseTestNominatim.test_user_agent_custom": [], "test.geocoders.nominatim.BaseTestNominatim.test_reverse": [], "test.geocoders.nominatim.BaseTestNominatim.test_reverse_near_zero": [], "test.geocoders.nominatim.BaseTestNominatim.test_structured_query": [], "test.geocoders.nominatim.BaseTestNominatim.test_city_district_with_dict_query": [], "test.geocoders.nominatim.BaseTestNominatim.test_geocode_language_parameter": [], "test.geocoders.nominatim.BaseTestNominatim.test_reverse_language_parameter": [], "test.geocoders.nominatim.BaseTestNominatim.test_geocode_geometry_wkt": [], "test.geocoders.nominatim.BaseTestNominatim.test_geocode_geometry_svg": [], "test.geocoders.nominatim.BaseTestNominatim.test_geocode_geometry_kml": [], "test.geocoders.nominatim.BaseTestNominatim.test_geocode_geometry_geojson": [], "test.geocoders.nominatim.BaseTestNominatim.test_missing_reverse_details": [], "test.geocoders.nominatim.BaseTestNominatim.test_viewbox": [], "test.geocoders.nominatim.BaseTestNominatim.test_bounded": ["geopy.point.Point"], "test.geocoders.nominatim.BaseTestNominatim.test_extratags": [], "test.geocoders.nominatim.BaseTestNominatim.test_country_codes_moscow": [], "test.geocoders.nominatim.BaseTestNominatim.test_country_codes_str": [], "test.geocoders.nominatim.BaseTestNominatim.test_country_codes_list": [], "test.geocoders.nominatim.BaseTestNominatim.test_featuretype_param": [], "test.geocoders.nominatim.BaseTestNominatim.test_geocode_namedetails": [], "test.geocoders.nominatim.BaseTestNominatim.test_reverse_namedetails": [], "test.geocoders.nominatim.BaseTestNominatim.test_reverse_zoom_parameter": [], "test.geocoders.nominatim.TestNominatim.make_geocoder": ["geopy.geocoders.Nominatim"], "geopy.geocoders.Nominatim": [], "test.geocoders.nominatim.TestNominatim.test_default_user_agent_error": ["geopy.geocoders.Nominatim", "pytest.raises"], "test.geocoders.nominatim.TestNominatim.test_example_user_agent_error": ["geopy.geocoders.Nominatim", "pytest.raises"], "test.geocoders.nominatim.TestNominatim.test_custom_user_agent_works": ["geopy.geocoders.Nominatim", "unittest.mock.patch.object"], "test.geocoders.nominatim.TestNominatim.test_import_deprecated_osm_module": ["<builtin>.len", "warnings.catch_warnings"], "test.geocoders.yandex": [], "test.geocoders.yandex.TestYandex.make_geocoder": ["geopy.geocoders.Yandex"], "geopy.geocoders.Yandex": [], "test.geocoders.yandex.TestYandex.test_user_agent_custom": ["geopy.geocoders.Yandex"], "test.geocoders.yandex.TestYandex.test_geocode": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.yandex.TestYandex.test_failure_with_invalid_api_key": ["test.geocoders.util.BaseTestGeocoder.inject_geocoder", "geopy.geocoders.Yandex", "pytest.raises", "test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.yandex.TestYandex.test_reverse": ["test.geocoders.util.BaseTestGeocoder.reverse_run"], "test.geocoders.yandex.TestYandex.test_geocode_lang": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.yandex.TestYandex.test_reverse_kind": ["test.geocoders.util.BaseTestGeocoder.reverse_run"], "test.geocoders.yandex.TestYandex.test_reverse_lang": ["test.geocoders.util.BaseTestGeocoder.reverse_run"], "test.geocoders.ignfrance": [], "test.geocoders.ignfrance.TestIGNFrance.make_geocoder": ["geopy.geocoders.IGNFrance"], "geopy.geocoders.IGNFrance": [], "test.geocoders.ignfrance.TestIGNFrance.test_invalid_query_type": ["pytest.raises"], "test.geocoders.ignfrance.TestIGNFrance.test_invalid_query_parcel": ["pytest.raises"], "test.geocoders.ignfrance.TestIGNFrance.test_geocode": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.ignfrance.TestIGNFrance.test_geocode_no_result": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.ignfrance.TestIGNFrance.test_reverse_no_result": ["test.geocoders.util.BaseTestGeocoder.reverse_run"], "test.geocoders.ignfrance.TestIGNFrance.test_geocode_with_address": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.ignfrance.TestIGNFrance.test_geocode_freeform": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.ignfrance.TestIGNFrance.test_geocode_position_of_interest": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.ignfrance.TestIGNFrance.test_geocode_filter_by_attribute": ["<builtin>.set", "<builtin>.len", "test.geocoders.util.BaseTestGeocoder.geocode_run", "<builtin>.list"], "test.geocoders.ignfrance.TestIGNFrance.test_geocode_filter_by_envelope": ["<builtin>.len", "test.geocoders.util.BaseTestGeocoder.geocode_run", "<builtin>.list"], "test.geocoders.ignfrance.TestIGNFrance.test_reverse": ["test.geocoders.util.BaseTestGeocoder.reverse_run"], "test.geocoders.ignfrance.TestIGNFrance.test_reverse_invalid_preference": ["pytest.raises"], "test.geocoders.ignfrance.TestIGNFrance.test_reverse_preference": ["test.geocoders.util.BaseTestGeocoder.reverse_run"], "test.geocoders.ignfrance.TestIGNFrance.test_reverse_by_radius": ["<builtin>.str", "test.geocoders.util.BaseTestGeocoder.reverse_run"], "test.geocoders.ignfrance.TestIGNFranceUsernameAuthProxy.make_geocoder": ["geopy.geocoders.IGNFrance"], "test.geocoders.ignfrance.TestIGNFranceUsernameAuthProxy": ["pytest.fixture"], "test.geocoders.ignfrance.TestIGNFranceUsernameAuthProxy.start_proxy": ["test.proxy_server.ProxyServerThread"], "test.proxy_server.ProxyServerThread": [], "test.geocoders.ignfrance.TestIGNFranceUsernameAuthProxy.test_proxy_is_respected": ["<builtin>.len", "test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.databc": [], "test.geocoders.databc.TestDataBC.make_geocoder": ["geopy.geocoders.DataBC"], "geopy.geocoders.DataBC": [], "test.geocoders.databc.TestDataBC.test_user_agent_custom": ["geopy.geocoders.DataBC"], "test.geocoders.databc.TestDataBC.test_geocode": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.databc.TestDataBC.test_multiple_results": ["<builtin>.len", "test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.databc.TestDataBC.test_optional_params": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.databc.TestDataBC.test_query_error": ["pytest.raises", "test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.pelias": [], "test.geocoders.pelias.BaseTestPelias.test_geocode": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.pelias.BaseTestPelias.test_reverse": ["geopy.point.Point", "test.geocoders.util.BaseTestGeocoder.reverse_run"], "test.geocoders.pelias.BaseTestPelias.test_boundary_rect": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.pelias.BaseTestPelias.test_geocode_language_parameter": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.pelias.BaseTestPelias.test_reverse_language_parameter": ["test.geocoders.util.BaseTestGeocoder.reverse_run"], "test.geocoders.pelias.BaseTestPelias.test_geocode_country_bias": ["warnings.catch_warnings", "warnings.simplefilter", "<builtin>.len", "test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.pelias.BaseTestPelias.test_geocode_countries": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.pelias.TestPelias.make_geocoder": ["geopy.geocoders.Pelias"], "geopy.geocoders.Pelias": [], "test.geocoders.geocodeearth": [], "test.geocoders.geocodeearth.TestGeocodeEarth.make_geocoder": ["geopy.geocoders.GeocodeEarth"], "geopy.geocoders.GeocodeEarth": [], "test.geocoders.mapquest": [], "test.geocoders.mapquest.TestMapQuest.make_geocoder": ["geopy.geocoders.MapQuest"], "geopy.geocoders.MapQuest": [], "test.geocoders.mapquest.TestMapQuest.test_geocode": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.mapquest.TestMapQuest.test_reverse": ["geopy.point.Point", "test.geocoders.util.BaseTestGeocoder.reverse_run"], "test.geocoders.mapquest.TestMapQuest.test_zero_results": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.mapquest.TestMapQuest.test_geocode_bbox": ["geopy.point.Point", "test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.mapquest.TestMapQuest.test_geocode_raw": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.mapquest.TestMapQuest.test_geocode_limit": ["<builtin>.len", "test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.tomtom": [], "test.geocoders.tomtom.BaseTestTomTom.test_user_agent_custom": [], "test.geocoders.tomtom.BaseTestTomTom.test_geocode": [], "test.geocoders.tomtom.BaseTestTomTom.test_reverse": [], "test.geocoders.tomtom.BaseTestTomTom.test_geocode_empty": [], "test.geocoders.tomtom.TestTomTom.make_geocoder": ["geopy.geocoders.TomTom"], "geopy.geocoders.TomTom": [], "test.geocoders.what3words": [], "test.geocoders.what3words.TestUnitWhat3Words.test_user_agent_custom": ["geopy.geocoders.What3Words"], "geopy.geocoders.What3Words": [], "test.geocoders.what3words.TestUnitWhat3Words": ["unittest.mock.patch.object"], "test.geocoders.what3words.TestUnitWhat3Words.test_default_scheme_is_ignored": ["geopy.geocoders.What3Words"], "test.geocoders.what3words.TestUnitWhat3Words.test_check_query": ["geopy.geocoders.what3words._check_query"], "geopy.geocoders.what3words._check_query": [], "test.geocoders.what3words.BaseTestWhat3Words.test_geocode": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.what3words.BaseTestWhat3Words.test_reverse": ["test.geocoders.util.BaseTestGeocoder.reverse_run"], "test.geocoders.what3words.BaseTestWhat3Words.test_unicode_query": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.what3words.BaseTestWhat3Words.test_empty_response": ["pytest.raises", "test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.what3words.BaseTestWhat3Words.test_not_exactly_one": ["test.geocoders.util.BaseTestGeocoder.reverse_run", "test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.what3words.BaseTestWhat3Words.test_reverse_language": ["test.geocoders.util.BaseTestGeocoder.reverse_run"], "test.geocoders.what3words.TestWhat3Words.make_geocoder": ["geopy.geocoders.What3Words"], "test.geocoders.what3words.TestWhat3Words.test_geocode_language": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.what3words.TestWhat3WordsV3.make_geocoder": ["geopy.geocoders.What3WordsV3"], "geopy.geocoders.What3WordsV3": [], "test.geocoders.pickpoint": [], "test.geocoders.pickpoint.TestPickPoint.make_geocoder": ["geopy.geocoders.PickPoint"], "geopy.geocoders.PickPoint": [], "test.geocoders.pickpoint.TestPickPoint.test_no_nominatim_user_agent_warning": ["warnings.simplefilter", "<builtin>.len", "warnings.catch_warnings", "geopy.geocoders.PickPoint"], "test.geocoders.geolake": [], "test.geocoders.geolake.TestUnitGeolake.test_user_agent_custom": ["geopy.geocoders.Geolake"], "geopy.geocoders.Geolake": [], "test.geocoders.geolake.TestGeolake.make_geocoder": ["geopy.geocoders.Geolake"], "test.geocoders.geolake.TestGeolake.test_geocode": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.geolake.TestGeolake.test_geocode_country_codes_str": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.geolake.TestGeolake.test_geocode_country_codes_list": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.geolake.TestGeolake.test_geocode_structured": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.geolake.TestGeolake.test_geocode_empty_result": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.geocoders.geolake.TestGeolake.test_geocode_missing_city_in_result": ["test.geocoders.util.BaseTestGeocoder.geocode_run"], "test.adapters.retry_after": ["pytest.mark.parametrize"], "test.adapters.retry_after.test_get_retry_after": ["geopy.adapters.get_retry_after", "datetime.datetime", "unittest.mock.patch.object"], "geopy.adapters.get_retry_after": [], "test.adapters.each_adapter": ["<builtin>.bool", "urllib.request.getproxies", "contextlib.asynccontextmanager", "os.path.join", "pytest.fixture", "pytest.mark.parametrize", "pytest.mark.skipif", "os.path.dirname"], "os.path.dirname": [], "os.path.join": [], "urllib.request.getproxies": [], "<builtin>.bool": [], "test.adapters.each_adapter.DummyGeocoder.geocode": ["geopy.geocoders.base.Geocoder._call_geocoder"], "test.adapters.each_adapter.DummyGeocoder.geocode.<lambda1>": [], "geopy.geocoders.base.Geocoder._call_geocoder": [], "test.adapters.each_adapter.timeout": [], "test.adapters.each_adapter.proxy_server_thread": ["test.proxy_server.ProxyServerThread"], "test.adapters.each_adapter.proxy_server": [], "test.adapters.each_adapter.proxy_url": [], "test.adapters.each_adapter.inject_proxy_to_system_env": ["os.environ.pop", "os.environ.get"], "os.environ.get": [], "os.environ.pop": [], "test.adapters.each_adapter.http_server": ["test.proxy_server.HttpServerThread"], "test.proxy_server.HttpServerThread": [], "test.adapters.each_adapter.remote_website_trusted_https": [], "test.adapters.each_adapter.remote_website_http": [], "test.adapters.each_adapter.remote_website_http_json": ["urllib.parse.urljoin"], "urllib.parse.urljoin": [], "test.adapters.each_adapter.remote_website_http_json_plain": ["urllib.parse.urljoin"], "test.adapters.each_adapter.remote_website_http_404": ["urllib.parse.urljoin"], "test.adapters.each_adapter.adapter_factory": ["unittest.mock.patch.object"], "test.adapters.each_adapter.make_dummy_async_geocoder": ["geopy.geocoders.base.Geocoder.__init__", "<builtin>.isinstance"], "test.adapters.each_adapter.make_dummy_async_geocoder.geocode": ["test.adapters.each_adapter.DummyGeocoder.geocode", "test.adapters.each_adapter.make_dummy_async_geocoder.geocode"], "test.adapters.each_adapter.test_not_available_adapters_raise": ["pytest.raises", "test.adapters.each_adapter.make_dummy_async_geocoder", "unittest.mock.patch.object"], "test.adapters.each_adapter.test_geocoder_constructor_uses_https_proxy": ["urllib.request.urlopen", "test.adapters.each_adapter.make_dummy_async_geocoder", "<builtin>.len"], "urllib.request.urlopen": [], "test.adapters.each_adapter.test_geocoder_http_proxy_auth_is_respected": ["urllib.request.urlopen", "test.adapters.each_adapter.make_dummy_async_geocoder", "<builtin>.len"], "test.adapters.each_adapter.test_geocoder_https_proxy_auth_is_respected": ["urllib.request.urlopen", "test.adapters.each_adapter.make_dummy_async_geocoder", "<builtin>.len"], "test.adapters.each_adapter.test_geocoder_http_proxy_auth_error": ["pytest.raises", "test.adapters.each_adapter.make_dummy_async_geocoder"], "test.adapters.each_adapter.test_geocoder_https_proxy_auth_error": ["pytest.raises", "test.adapters.each_adapter.make_dummy_async_geocoder"], "test.adapters.each_adapter.test_ssl_context_with_proxy_is_respected": ["test.adapters.each_adapter.make_dummy_async_geocoder", "<builtin>.str", "pytest.raises", "ssl.create_default_context", "<builtin>.len"], "ssl.create_default_context": [], "test.adapters.each_adapter.test_ssl_context_without_proxy_is_respected": ["ssl.create_default_context", "<builtin>.str", "pytest.raises", "test.adapters.each_adapter.make_dummy_async_geocoder"], "test.adapters.each_adapter.test_geocoder_constructor_uses_http_proxy": ["urllib.request.urlopen", "test.adapters.each_adapter.make_dummy_async_geocoder", "<builtin>.len"], "test.adapters.each_adapter.test_geocoder_constructor_uses_str_proxy": ["urllib.request.urlopen", "test.adapters.each_adapter.make_dummy_async_geocoder", "<builtin>.len"], "test.adapters.each_adapter.test_geocoder_constructor_has_both_schemes_proxy": ["geopy.geocoders.base.Geocoder.__init__"], "test.adapters.each_adapter.test_get_json": ["<builtin>.isinstance", "test.adapters.each_adapter.make_dummy_async_geocoder"], "test.adapters.each_adapter.test_get_json_plain": ["<builtin>.isinstance", "test.adapters.each_adapter.make_dummy_async_geocoder"], "test.adapters.each_adapter.test_get_json_failure_on_non_json": ["pytest.raises", "test.adapters.each_adapter.make_dummy_async_geocoder"], "test.adapters.each_adapter.test_adapter_exception_for_non_200_response": ["pytest.raises", "<builtin>.isinstance", "test.adapters.each_adapter.make_dummy_async_geocoder"], "test.adapters.each_adapter.test_system_proxies_are_respected_by_default": ["<builtin>.len", "test.adapters.each_adapter.make_dummy_async_geocoder"], "test.adapters.each_adapter.test_system_proxies_are_respected_with_none": ["<builtin>.len", "test.adapters.each_adapter.make_dummy_async_geocoder"], "test.adapters.each_adapter.test_system_proxies_are_reset_with_empty_dict": ["<builtin>.len", "test.adapters.each_adapter.make_dummy_async_geocoder"], "test.adapters.each_adapter.test_string_value_overrides_system_proxies": ["<builtin>.len", "test.adapters.each_adapter.make_dummy_async_geocoder"], "test.adapters": [], "test.test_init": [], "test.test_init.test_version": ["<builtin>.isinstance"], "test.test_init.test_version_info": ["<builtin>.tuple", "distutils.version.LooseVersion"], "distutils.version.LooseVersion": [], "test.test_init.test_get_version": ["<builtin>.isinstance", "geopy.get_version"], "geopy.get_version": [], "test.test_location": ["geopy.point.Point"], "test.test_location.LocationTestCase._location_iter_test": ["unittest.TestCase.assertEqual"], "test.test_location.LocationTestCase._location_properties_test": ["unittest.TestCase.assertEqual"], "test.test_location.LocationTestCase.test_location_str": ["test.test_location.LocationTestCase._location_iter_test", "unittest.TestCase.assertEqual", "geopy.location.Location"], "geopy.location.Location": [], "test.test_location.LocationTestCase.test_location_point": ["test.test_location.LocationTestCase._location_iter_test", "unittest.TestCase.assertEqual", "geopy.location.Location"], "test.test_location.LocationTestCase.test_location_none": ["geopy.location.Location", "unittest.TestCase.assertRaises"], "test.test_location.LocationTestCase.test_location_iter": ["test.test_location.LocationTestCase._location_iter_test", "unittest.TestCase.assertEqual", "geopy.location.Location"], "test.test_location.LocationTestCase.test_location_point_typeerror": ["geopy.location.Location", "unittest.TestCase.assertRaises"], "test.test_location.LocationTestCase.test_location_array_access": ["unittest.TestCase.assertEqual", "geopy.location.Location"], "test.test_location.LocationTestCase.test_location_properties": ["test.test_location.LocationTestCase._location_properties_test", "geopy.location.Location"], "test.test_location.LocationTestCase.test_location_raw": ["test.test_location.LocationTestCase._location_properties_test", "geopy.location.Location"], "test.test_location.LocationTestCase.test_location_string": ["<builtin>.str", "unittest.TestCase.assertEqual", "geopy.location.Location"], "test.test_location.LocationTestCase.test_location_len": ["<builtin>.len", "geopy.location.Location", "unittest.TestCase.assertEqual"], "test.test_location.LocationTestCase.test_location_eq": ["unittest.TestCase.assertEqual", "geopy.location.Location"], "test.test_location.LocationTestCase.test_location_ne": ["unittest.TestCase.assertNotEqual", "geopy.point.Point", "geopy.location.Location"], "unittest.TestCase.assertNotEqual": [], "test.test_location.LocationTestCase.test_location_repr": ["<builtin>.repr", "unittest.TestCase.assertEqual", "geopy.location.Location"], "<builtin>.repr": [], "test.test_location.LocationTestCase.test_location_is_picklable": ["pickle.dumps", "unittest.TestCase.assertEqual", "geopy.location.Location", "pickle.loads"], "test.test_location.LocationTestCase.test_location_with_unpicklable_raw": ["<builtin>.type", "<builtin>.dict", "pickle.dumps", "unittest.TestCase.assertRaises", "geopy.location.Location"], "<builtin>.dict": [], "test.test_format": ["pytest.mark.xfail", "pytest.mark.parametrize"], "test.test_format.test_format_simple": ["geopy.format.format_degrees", "geopy.point.Point.parse_degrees"], "geopy.point.Point.parse_degrees": [], "geopy.format.format_degrees": [], "pytest.mark.xfail": [], "test.test_format.test_format_float_precision": ["geopy.format.format_degrees", "geopy.point.Point.parse_degrees"], "test.conftest": ["<builtin>.set", "pytest.fixture", "<builtin>.float", "test.conftest.load_adapter_cls", "os.getenv", "<builtin>.int", "<builtin>.issubclass"], "test.conftest.load_adapter_cls": ["<builtin>.getattr", "importlib.import_module"], "os.getenv": [], "<builtin>.int": [], "test.conftest.pytest_report_header": ["test.conftest._is_internet_access_allowed"], "test.conftest._is_internet_access_allowed": [], "test.conftest.pytest_addoption": [], "test.conftest.is_internet_access_allowed": ["test.conftest._is_internet_access_allowed"], "test.conftest.skip_if_internet_access_is_not_allowed": ["pytest.skip"], "test.conftest.event_loop": ["asyncio.set_event_loop", "asyncio.new_event_loop"], "asyncio.new_event_loop": [], "asyncio.set_event_loop": [], "test.conftest.netloc_from_url": ["urllib.parse.urlparse"], "test.conftest.pretty_dict_format": ["<builtin>.sorted", "<builtin>.len", "test.conftest.RequestsMonitor.__str__.value_mapper", "<builtin>.max", "test.conftest.<lambda1>"], "<builtin>.max": [], "test.conftest.RequestsMonitor.__str__.value_mapper": ["statistics.median", "<builtin>.min", "<builtin>.float", "<builtin>.sum", "statistics.mean", "<builtin>.max"], "test.conftest.<lambda1>": [], "test.conftest.RequestsMonitor.__init__": ["collections.defaultdict"], "test.conftest.RequestsMonitor.__init__.<lambda1>": ["<builtin>.dict"], "collections.defaultdict": [], "test.conftest.RequestsMonitor.record_request": ["test.conftest.netloc_from_url"], "test.conftest.RequestsMonitor.record_retry": ["test.conftest.netloc_from_url"], "test.conftest.RequestsMonitor": ["contextlib.contextmanager"], "contextlib.contextmanager": [], "test.conftest.RequestsMonitor.record_response": ["timeit.default_timer", "test.conftest.netloc_from_url"], "timeit.default_timer": [], "test.conftest.RequestsMonitor.__str__": ["test.conftest.pretty_dict_format"], "<builtin>.min": [], "statistics.median": [], "statistics.mean": [], "<builtin>.sum": [], "test.conftest.requests_monitor": ["test.conftest.RequestsMonitor.__init__"], "test.conftest.print_requests_monitor_report": ["atexit.register"], "test.conftest.print_requests_monitor_report.report": ["<builtin>.str", "<builtin>.print"], "<builtin>.print": [], "atexit.register": [], "test.conftest.retries_enabled_session": ["types.SimpleNamespace"], "types.SimpleNamespace": [], "test.conftest.disable_adapter_retries": [], "test.conftest.patch_adapter": ["functools.partial", "unittest.mock.patch.object"], "test.conftest.patch_adapter.AdapterProxy.__aenter__": [], "test.conftest.patch_adapter.AdapterProxy.__aexit__": [], "test.conftest.patch_adapter.AdapterProxy._wrapped_get": ["<builtin>.next", "asyncio.sleep", "time.sleep", "test.conftest.BaseAdapterProxy._retries"], "test.conftest.BaseAdapterProxy._retries": ["<builtin>.RuntimeError", "pytest.skip", "test.conftest.netloc_from_url", "<builtin>.range"], "<builtin>.next": [], "asyncio.sleep": [], "time.sleep": [], "functools.partial": [], "test.conftest.BaseAdapterProxy.__init__": [], "test.conftest.BaseAdapterProxy.get_json": ["functools.partial"], "test.conftest.BaseAdapterProxy.get_text": ["functools.partial"], "test": [], "test.extra.rate_limiter": ["pytest.fixture"], "test.extra.rate_limiter.is_async": [], "test.extra.rate_limiter.auto_async": [], "test.extra.rate_limiter.auto_async.auto_async": [], "test.extra.rate_limiter.auto_async_side_effect": [], "test.extra.rate_limiter.auto_async_side_effect.auto_async_side_effect": ["unittest.mock.MagicMock"], "unittest.mock.MagicMock": [], "test.extra.rate_limiter.auto_async_side_effect.auto_async_side_effect.func": [], "test.extra.rate_limiter.rate_limiter_cls": [], "test.extra.rate_limiter.mock_clock": ["unittest.mock.patch.object"], "test.extra.rate_limiter.mock_sleep": ["unittest.mock.patch.object"], "test.extra.rate_limiter.test_min_delay": ["unittest.mock.MagicMock"], "test.extra.rate_limiter.test_max_retries": ["unittest.mock.MagicMock", "pytest.raises"], "test.extra.rate_limiter.test_error_wait_seconds": ["unittest.mock.MagicMock"], "test.extra.rate_limiter.test_sync_raises_for_awaitable": ["pytest.raises", "geopy.extra.rate_limiter.RateLimiter"], "test.extra.rate_limiter.test_sync_raises_for_awaitable.g": ["asyncio.ensure_future", "test.extra.rate_limiter.test_sync_raises_for_awaitable.g.coro"], "test.extra.rate_limiter.test_sync_raises_for_awaitable.g.coro": [], "asyncio.ensure_future": [], "geopy.extra.rate_limiter.RateLimiter": [], "test.extra": [], "test.proxy_server": [], "test.proxy_server.pipe_sockets": ["<builtin>.next", "select.select"], "select.select": [], "test.proxy_server.Future.__init__": ["threading.Event"], "threading.Event": [], "test.proxy_server.Future.result": ["<builtin>.AssertionError"], "<builtin>.AssertionError": [], "test.proxy_server.Future.set_result": [], "test.proxy_server.Future.set_exception": [], "test.proxy_server.ProxyServerThread.__init__": ["<builtin>.super", "test.proxy_server.Future.__init__"], "test.proxy_server.ProxyServerThread.reset": [], "test.proxy_server.ProxyServerThread.__enter__": [], "test.proxy_server.ProxyServerThread.__exit__": [], "test.proxy_server.ProxyServerThread.set_auth": [], "test.proxy_server.ProxyServerThread.get_proxy_url": [], "test.proxy_server.ProxyServerThread.run": ["socketserver.ThreadingTCPServer"], "test.proxy_server.ProxyServerThread.run.Proxy.check_auth": ["http.server.SimpleHTTPRequestHandler.headers.get", "base64.standard_b64encode", "http.server.SimpleHTTPRequestHandler.send_header", "http.server.SimpleHTTPRequestHandler.connection.close", "http.server.SimpleHTTPRequestHandler.wfile.write", "http.server.SimpleHTTPRequestHandler.send_response", "http.server.SimpleHTTPRequestHandler.end_headers"], "http.server.SimpleHTTPRequestHandler.headers.get": [], "base64.standard_b64encode": [], "http.server.SimpleHTTPRequestHandler.send_response": [], "http.server.SimpleHTTPRequestHandler.send_header": [], "http.server.SimpleHTTPRequestHandler.end_headers": [], "http.server.SimpleHTTPRequestHandler.wfile.write": [], "http.server.SimpleHTTPRequestHandler.connection.close": [], "test.proxy_server.ProxyServerThread.run.Proxy.do_GET": ["http.server.SimpleHTTPRequestHandler.send_header", "http.server.SimpleHTTPRequestHandler.connection.close", "urllib.request.urlopen", "test.proxy_server.ProxyServerThread.run.Proxy.check_auth", "http.server.SimpleHTTPRequestHandler.copyfile", "http.server.SimpleHTTPRequestHandler.send_response", "http.server.SimpleHTTPRequestHandler.end_headers"], "http.server.SimpleHTTPRequestHandler.copyfile": [], "test.proxy_server.ProxyServerThread.run.Proxy.do_CONNECT": ["test.proxy_server.pipe_sockets", "http.server.SimpleHTTPRequestHandler.send_error", "http.server.SimpleHTTPRequestHandler.end_headers", "http.server.SimpleHTTPRequestHandler.send_header", "test.proxy_server.ProxyServerThread.run.Proxy.check_auth", "<builtin>.int", "http.server.SimpleHTTPRequestHandler.send_response", "socket.create_connection"], "socket.create_connection": [], "http.server.SimpleHTTPRequestHandler.send_error": [], "socketserver.ThreadingTCPServer": [], "test.proxy_server.ProxyServerThread.stop": [], "test.proxy_server.HttpServerThread.__init__": ["<builtin>.super", "test.proxy_server.Future.__init__"], "test.proxy_server.HttpServerThread.__enter__": [], "test.proxy_server.HttpServerThread.__exit__": [], "test.proxy_server.HttpServerThread.get_server_url": [], "test.proxy_server.HttpServerThread.run": ["socketserver.ThreadingTCPServer"], "test.proxy_server.HttpServerThread.run.Server.do_GET": ["http.server.SimpleHTTPRequestHandler.send_header", "http.server.SimpleHTTPRequestHandler.connection.close", "http.server.SimpleHTTPRequestHandler.wfile.write", "http.server.SimpleHTTPRequestHandler.send_response", "http.server.SimpleHTTPRequestHandler.end_headers"], "test.proxy_server.HttpServerThread.stop": [], "test.test_distance": ["geopy.point.Point"], "test.test_distance.CommonDistanceComputationCases.test_zero_measure": [], "test.test_distance.CommonDistanceComputationCases.test_should_have_length_when_only_given_length": [], "test.test_distance.CommonDistanceComputationCases.test_should_have_zero_distance_for_coincident_points": [], "test.test_distance.CommonDistanceComputationCases.test_should_have_nonzero_distance_for_distinct_points": [], "test.test_distance.CommonDistanceComputationCases.test_max_longitude": [], "test.test_distance.CommonDistanceComputationCases.test_should_compute_distance_for_trip_between_poles": [], "test.test_distance.CommonDistanceComputationCases.test_should_compute_destination_for_trip_between_poles": [], "test.test_distance.CommonDistanceComputationCases.test_destination_bearing_east": ["geopy.point.Point"], "test.test_distance.CommonDistanceComputationCases.test_should_recognize_equivalence_of_pos_and_neg_180_longitude": [], "test.test_distance.CommonDistanceComputationCases.test_should_compute_distance_across_antimeridian": [], "test.test_distance.CommonDistanceComputationCases.test_should_compute_destination_across_antimeridian": [], "test.test_distance.CommonDistanceComputationCases.test_should_not_tolerate_nans": ["<builtin>.float"], "test.test_distance.CommonDistanceComputationCases.test_should_compute_distance_for_multiple_points_pairwise": [], "test.test_distance.CommonDistanceComputationCases.test_should_raise_when_using_single_numbers_as_points": [], "test.test_distance.CommonDistanceComputationCases.test_should_tolerate_tuples_with_textual_numbers": [], "test.test_distance.CommonDistanceComputationCases.test_should_warn_for_mixed_up_lat_lon": ["warnings.simplefilter", "<builtin>.len", "warnings.catch_warnings"], "test.test_distance.CommonDistanceComputationCases.test_should_get_consistent_results_for_distance_calculations": ["<builtin>.range"], "test.test_distance.CommonMathematicalOperatorCases.test_should_be_able_to_add_distances": [], "test.test_distance.CommonMathematicalOperatorCases.test_should_not_allow_adding_with_objects_that_arent_distances": [], "test.test_distance.CommonMathematicalOperatorCases.test_should_be_able_to_negate_distances": [], "test.test_distance.CommonMathematicalOperatorCases.test_should_be_able_to_subtract_distances": [], "test.test_distance.CommonMathematicalOperatorCases.test_should_be_able_to_multiply_distances_by_floats": [], "test.test_distance.CommonMathematicalOperatorCases.test_should_not_be_able_to_multiply_distances_by_distances": [], "test.test_distance.CommonMathematicalOperatorCases.test_should_not_be_able_to_divide_floats_by_distances": [], "test.test_distance.CommonMathematicalOperatorCases.test_should_be_able_to_divide_distances_by_distances": [], "test.test_distance.CommonMathematicalOperatorCases.test_should_be_able_to_floor_divide_distances_by_distances": [], "test.test_distance.CommonMathematicalOperatorCases.test_should_be_able_to_divide_distances_by_floats": [], "test.test_distance.CommonMathematicalOperatorCases.test_should_be_able_to_floor_divide_distances": [], "test.test_distance.CommonMathematicalOperatorCases.test_should_be_able_to_take_absolute_value_of_distances": ["<builtin>.abs"], "<builtin>.abs": [], "test.test_distance.CommonMathematicalOperatorCases.test_should_be_true_in_boolean_context_when_nonzero_length": [], "test.test_distance.CommonMathematicalOperatorCases.test_should_be_false_in_boolean_context_when_zero_length": [], "test.test_distance.CommonConversionCases.test_should_convert_to_kilometers": [], "test.test_distance.CommonConversionCases.test_should_convert_to_kilometers_with_abbreviation": [], "test.test_distance.CommonConversionCases.test_should_convert_to_meters": [], "test.test_distance.CommonConversionCases.test_should_convert_to_meters_with_abbreviation": [], "test.test_distance.CommonConversionCases.test_should_convert_to_miles": [], "test.test_distance.CommonConversionCases.test_should_convert_to_miles_with_abbreviation": [], "test.test_distance.CommonConversionCases.test_should_convert_to_feet": [], "test.test_distance.CommonConversionCases.test_should_convert_to_feet_with_abbreviation": [], "test.test_distance.CommonConversionCases.test_should_convert_to_nautical_miles": [], "test.test_distance.CommonConversionCases.test_should_convert_to_nautical_miles_with_abbrevation": [], "test.test_distance.CommonConversionCases.test_should_convert_from_meters": [], "test.test_distance.CommonConversionCases.test_should_convert_from_feet": [], "test.test_distance.CommonConversionCases.test_should_convert_from_miles": [], "test.test_distance.CommonConversionCases.test_should_convert_from_nautical_miles": [], "test.test_distance.CommonComparisonCases.test_should_support_comparison_with_distance": [], "test.test_distance.CommonComparisonCases.test_should_support_comparison_with_number": [], "test.test_distance.TestDefaultDistanceClass.test_default_distance": ["unittest.TestCase.assertEqual", "geopy.distance.distance"], "geopy.distance.distance": [], "test.test_distance.TestDefaultDistanceClass.test_lonlat_function": ["geopy.distance.lonlat", "unittest.TestCase.assertEqual"], "geopy.distance.lonlat": [], "test.test_distance.TestWhenComputingGreatCircleDistance.test_should_compute_distance_for_half_trip_around_equator": ["unittest.TestCase.assertEqual", "geopy.distance.GreatCircleDistance"], "geopy.distance.GreatCircleDistance": [], "test.test_distance.TestWhenComputingGreatCircleDistance.test_should_compute_destination_for_half_trip_around_equator": ["unittest.TestCase.assertAlmostEqual", "geopy.distance.GreatCircleDistance"], "unittest.TestCase.assertAlmostEqual": [], "test.test_distance.TestWhenComputingGreatCircleDistance.test_different_altitudes_error": ["unittest.TestCase.assertRaises", "geopy.distance.GreatCircleDistance"], "test.test_distance.TestWhenComputingGeodesicDistance.test_different_altitudes_error": ["geopy.distance.GeodesicDistance", "unittest.TestCase.assertRaises"], "geopy.distance.GeodesicDistance": [], "test.test_distance.TestWhenComputingGeodesicDistance.test_miscellaneous_high_accuracy_cases": ["unittest.TestCase.assertAlmostEqual", "geopy.distance.GeodesicDistance", "geopy.point.Point"], "test.test_distance.test_distance_hashing": ["geopy.distance.GeodesicDistance", "geopy.distance.Distance", "geopy.distance.GreatCircleDistance", "<builtin>.hash", "<builtin>.len"], "geopy.distance.Distance": [], "<builtin>.hash": [], "test.test_exc": ["inspect.isclass", "<builtin>.dir", "<builtin>.sorted", "pytest.mark.parametrize", "<builtin>.issubclass", "<builtin>.getattr"], "test.test_exc.<lambda1>": [], "test.test_exc.test_init": ["pytest.raises"], "test.test_timezone": [], "test.test_timezone.TimezoneTestCase.test_create_from_timezone_name": ["<builtin>.dict", "geopy.timezone.from_timezone_name", "unittest.TestCase.assertEqual", "unittest.TestCase.assertIsInstance"], "geopy.timezone.from_timezone_name": [], "unittest.TestCase.assertIsInstance": [], "test.test_timezone.TimezoneTestCase.test_create_from_fixed_gmt_offset": ["datetime.datetime.utcnow", "pytz.timezone", "<builtin>.dict", "geopy.timezone.from_fixed_gmt_offset", "unittest.TestCase.assertIsInstance", "unittest.TestCase.assertEqual"], "geopy.timezone.from_fixed_gmt_offset": [], "datetime.datetime.utcnow": [], "test.test_timezone.TimezoneTestCase.test_create_from_pytz_timezone": ["geopy.timezone.Timezone", "unittest.TestCase.assertIs", "pytz.timezone"], "geopy.timezone.Timezone": [], "unittest.TestCase.assertIs": [], "test.test_timezone.TimezoneTestCase.test_string": ["<builtin>.dict", "<builtin>.str", "geopy.timezone.from_timezone_name", "unittest.TestCase.assertEqual"], "test.test_timezone.TimezoneTestCase.test_repr": ["<builtin>.dict", "geopy.timezone.Timezone", "<builtin>.repr", "unittest.TestCase.assertEqual", "pytz.timezone"], "test.test_timezone.TimezoneTestCase.test_eq": ["<builtin>.dict", "geopy.timezone.Timezone", "pytz.timezone", "unittest.TestCase.assertEqual"], "test.test_timezone.TimezoneTestCase.test_ne": ["unittest.TestCase.assertNotEqual", "geopy.timezone.Timezone", "pytz.timezone"], "test.test_timezone.TimezoneTestCase.test_picklable": ["<builtin>.dict", "pickle.dumps", "pickle.loads", "geopy.timezone.from_timezone_name", "unittest.TestCase.assertEqual"], "test.test_timezone.TimezoneTestCase.test_with_unpicklable_raw": ["<builtin>.type", "<builtin>.dict", "pickle.dumps", "unittest.TestCase.assertRaises", "geopy.timezone.from_timezone_name"]}